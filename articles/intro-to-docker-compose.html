<!DOCTYPE html>
<head>
	<meta charset="utf-8"/>
	<title>Soladev</title>
	<link rel="stylesheet" type="text/css" href="../style.css">
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"> 
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet"> 
	<script type="text/javascript" src="../jquery-3.2.1.js"></script>
</head>
<body>
	<nav>
		<a href="../index.html">ARTICLES</a>
		<a href="./ctf">SOLA_CTF</a>
		<h1><a href="../index.html">Soladev</a></h1>
		<a href="../friends.html">LES AMIS</a>
		<a href="../me.html">QUI SUIS-JE</a> 
	</nav>
	<header>
	</header>
	<div class="content">
        <div class="article">
        <h2 id="introduction-docker-compose-">Introduction √† Docker Compose üê≥</h2>
<p>Nous allons maintenant parler de Docker Compose, un √©l√©ment qui va √™tre essentiel pour les futurs articles de ce site et une fonctionnalit√© tr√®s pratique de Docker.</p>
<h4 id="pourquoi-utiliser-docker-compose-">Pourquoi utiliser Docker Compose ?</h4>
<p>Nous avons d√©j√† vu comment lancer des containers, avec la commande <strong>docker run</strong>. Mais imaginons que nous devons utiliser une image apache2 avec deux ports mapp√©s, un volume, un red√©marrage automatique et la d√©finition d&#39;une variable d&#39;environnement, on doit √©crire :</p>
<pre><code>$ docker run -d \ 
  -<span class="ruby">p <span class="hljs-number">8080</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span> \ 
</span>  -<span class="ruby">p <span class="hljs-number">443</span><span class="hljs-symbol">:</span><span class="hljs-number">443</span> \ 
</span>  -<span class="ruby">v $(pwd)/source/<span class="hljs-symbol">:/var/www/html</span> \
</span>  -<span class="ruby">-restart-policy=always \
</span>  -<span class="ruby">e foo=bar \ 
</span>  -<span class="ruby">-name web-server \
</span>  httpd
</code></pre><p>Cela commence √† faire de longues commandes, que l&#39;on pourrait √™tre amen√© √† devoir retaper √† la main de z√©ro... De plus, on pourrait vouloir cr√©er des r√©seaux Docker virtuels pour le lier avec un reverse proxy et/ou une base de donn√©es, partager des volumes... La configuration &quot;en dur&quot; peut s&#39;av√©rer vite complexe.</p>
<p><strong>Docker Compose</strong> permet de r√©soudre tous ces probl√®mes. Comment ? Et bien √† la base, dans la philosophie de Docker, <strong>un container correspond √† un service</strong>. Pour d√©ployer une application, on peut avoir besoin de plusieurs services qui communiquent entre eux, donc <strong>des containers qui communiquent entre eux</strong>. Cela peut se faire en faisant des &quot;<strong>--link</strong>&quot; entre les containers en brut, liant les deux containers dans un r√©seau priv√© entre eux, mais cela peut vite devenir compliqu√© √† g√©rer. Docker Compose permet de <strong>composer une application en se basant sur plusieurs services</strong> et donc de faciliter leur d√©ploiement.</p>
<h4 id="sc-nario-d-utilisation-de-docker-compose">Sc√©nario d&#39;utilisation de Docker Compose</h4>
<p>Imaginons le sc√©nario suivant : vous devez d√©ployer une application Web poss√©dant les capacit√©s suivantes :</p>
<ul>
<li>Un <strong>Front-End Web en PHP</strong> (En version 7.2.3 parce que seule cette version fonctionne avec l&#39;application actuellement) ;</li>
<li>Un <strong>Front-End Web de test en PHP</strong> (Version la plus r√©cente pour faire des tests de fonctionnalit√©s) ;</li>
<li>Une <strong>base de donn√©es PostgreSQL</strong> ;</li>
<li>Un <strong>cache Redis</strong> ;</li>
<li>Un <strong>reverse proxy Nginx</strong> pour diriger les flux et n&#39;autoriser que certaines IPs sur le Front-end Web de test (un fichier de configuration est d√©j√† fourni).</li>
</ul>
<p>Le chef de projet souhaite aussi que seuls les ports 80 et 443 soient expos√©s sur Internet pour des raisons de s√©curit√©.</p>
<p>Pour coordonner le d√©ploiement de cette application, il vaut mieux utiliser Docker, car nous avons deux serveurs PHP avec des versions diff√©rentes. Les fonctionnalit√©s de r√©seaux virtuels de Docker permettent aussi de cacher les ports des bases de donn√©es. Mais organiser le tout ne sera pas facile si on utilise pas Docker Compose. Voyons voir comment il faut s&#39;y prendre.</p>
<h4 id="description-de-l-infrastructure-containeris-e-">Description de l&#39;infrastructure &quot;containeris√©e&quot;</h4>
<p>Faisons quelques sch√©mas pour commencer : on souhaite donc ce type d&#39;infrastructure :</p>
<img src="../medias/flux-docker-app.png" alt="flux-docker-app"></img> 
<p>(Petit clin d&#39;oeil √† <a href="https://twitter.com/b0rk">Julia Evans</a> pour le style de sch√©ma. Allez la suivre sur Twitter, elle fait des petits sch√©mas explicatifs de certaines technologies r√©guli√®rement et elle en a fait notamment sur les containers)  </p>
<p>Les containers peuvent communiquer sur un r√©seau priv√© commun au sein d&#39;une m√™me application Docker Compose, ce qui permet d&#39;isoler les diff√©rents ports et d&#39;√©viter d&#39;exposer la base de donn√©es sur Internet. Pour √ßa il faut bien comprendre ce qu&#39;on entend par mapping des ports lorsque l&#39;on utilise la commande <strong>docker run -p 8080:80</strong> : cela veut dire qu&#39;on ouvre un port sur la machine h√¥te (8080) qui redirige vers le port virtuel ouvert sur le container (80). Le serveur agit donc comme une sorte de firewall capable de translater des ports. Mais lorsque le container est lanc√©, il poss√®de toujours le port virtuel 80 d&#39;ouvert, que l&#39;on ait mapp√© le port ou non. En cr√©ant un r√©seau virtuel ayant pour routeur principal votre machine h√¥te, les containers peuvent communiquer entre eux sans crainte qu&#39;un utilisateur ext√©rieur se connecte √† un port non-autoris√© et acc√©der √† Internet via la machine h√¥te. </p>
<p>L&#39;objectif de NGINX est celui d&#39;un Reverse Proxy : Il permet notamment de rediriger des flux HTTP vers plusieurs serveurs (ou containers) en se basant sur certaines r√®gles (noms de domaine, ports...). Il permet dans cette configuration d&#39;autoriser une liste d&#39;adresses IP d√©finie √† acc√©der au service Web Test.</p>
<h4 id="-tape-1-la-structure-d-un-fichier-docker-compose">√âtape 1 : La structure d&#39;un fichier Docker Compose</h4>
<p>Pour commencer √† utiliser Docker Compose, il faut d√©j√† avoir un fichier <strong>docker-compose.yml</strong> plac√© dans le r√©pertoire de notre projet. On va √©crire dans ce fichier avec une syntaxe YAML :</p>
<pre><code><span class="hljs-symbol">version:</span> <span class="hljs-string">'3'</span>
<span class="hljs-symbol">services:</span>
<span class="hljs-symbol">networks:</span>
<span class="hljs-symbol">volumes:</span>
</code></pre><p>Il s&#39;agit des quatre grandes parties importantes d&#39;un fichier docker-compose.yml. La partie <strong>services</strong> va d√©finir tous les containers √† utiliser, la partie <strong>networks</strong> va d√©finir tous les r√©seaux virtuels et la partie <strong>volumes</strong> va d√©finir tous les volumes de donn√©es. La <strong>version</strong> permet √† Docker Compose de savoir quelle syntaxe le fichier va respecter. La version 3 est la plus r√©cente, mais vous verrez probablement souvent la version 2 de cit√©. Il ne s&#39;agit pas d&#39;un clin d‚Äô≈ìil √† Python, juste que la version 3 prend en charge le mode Docker Swarm pour les clusters mais r√©duit dans le m√™me temps quelques fonctionnalit√©s de la version 2.</p>
<h4 id="-tape-2-cr-ation-des-services">√âtape 2 : Cr√©ation des services</h4>
<p>Dans la section services, on va rajouter le container du <strong>premier front-end Web</strong> :</p>
<pre><code>version: '3'
services:
  prod-web:   # Ce nom est arbitraire, mieux vaut qu'il soit explicite
    image: php:7.2.3-alpine
    restart: always
    volumes:
      -<span class="ruby"> ./source/<span class="hljs-symbol">:/var/www/html/</span><span class="hljs-symbol">:ro</span>
</span>    networks:
      -<span class="ruby"> main_network</span>
</code></pre><p>Et juste comme √ßa, nous avons d√©fini dans un fichier la cr√©ation d&#39;un service / container, nomm√© &quot;prod-web&quot;, avec la r√©cup√©ration du code source dans un dossier de la machine h√¥te. Ce dossier est mont√© en lecture seule sur le container par simple mesure de s√©curit√©. Vous pouvez d√©j√† vous demander o√π sont pass√©s les ports. Nous reviendrons √† cela un peu plus tard.</p>
<p>On va maintenant passer aux bases de donn√©es <strong>PostgreSQL</strong> et <strong>Redis</strong>. L&#39;image Docker nous permet de faire beaucoup de choses directement niveau configuration et on peut tout faire √† la suite du service pr√©c√©dent dans le fichier docker-compose.yml :</p>
<pre><code>  d<span class="hljs-variable">b:</span>
    image: postgre<span class="hljs-variable">s:alpine</span>
    restar<span class="hljs-variable">t:</span> always
    volume<span class="hljs-variable">s:</span>
      - db_dat<span class="hljs-variable">a:</span>/var/lib/postgresql/data
    environmen<span class="hljs-variable">t:</span>
      - POSTGRES_PASSWORD=Ch4Ng3_m3
      - POSTGRES_USER=postgres
      - POSTGRES_DB=production
    network<span class="hljs-variable">s:</span>
      - main_network

  <span class="hljs-keyword">redi</span><span class="hljs-variable">s:</span>
    image: <span class="hljs-keyword">redi</span><span class="hljs-variable">s:5</span>.<span class="hljs-number">0.7</span>-alpine
    restar<span class="hljs-variable">t:</span> always
    network<span class="hljs-variable">s:</span>
      - main_network
</code></pre><p>Redis agit comme un cache et ne requiert quasiment jamais de configuration. La base de donn√©es PostgreSQL quant √† elle a besoin d&#39;un mot de passe √† minima, mais on peut pr√©ciser un utilisateur √† ajouter et le nom de la base de donn√©es. Le volume <strong>db_data</strong> va √™tre cr√©√© pour faire une r√©tention des donn√©es, m√™me quand le container va √™tre supprim√© / recr√©√©. </p>
<p>Enfin, on configure le serveur <strong>NGINX</strong>, qui est le seul √† poss√©der des ports expos√©s vers l&#39;ext√©rieur :</p>
<pre><code>  nginx:
    image: nginx:alpine
    restart: always
    ports:
      -<span class="ruby"> <span class="hljs-number">80</span><span class="hljs-symbol">:</span><span class="hljs-number">80</span>
</span>      -<span class="ruby"> <span class="hljs-number">443</span><span class="hljs-symbol">:</span><span class="hljs-number">443</span>
</span>    volumes:
      -<span class="ruby"> ./nginx.<span class="hljs-symbol">conf:</span>/etc/nginx/nginx.<span class="hljs-symbol">conf:</span>ro
</span>      -<span class="ruby"> ./nginx-files/<span class="hljs-symbol">:/etc/nginx/conf</span>.d/<span class="hljs-symbol">:ro</span>
</span>    networks:
      -<span class="ruby"> main_network</span>
</code></pre><p>Les volumes d√©clar√©s ici sont pour placer toutes les configurations n√©cessaires √† NGINX. Il existe d&#39;autres images int√©ressantes pour NGINX mais nous en parlerons un autre jour.</p>
<p>La configuration du serveur de test est tr√®s similaire au premier service. Voyons maintenant les autres configurations √† faire.</p>
<h4 id="-tape-3-cr-ation-des-r-seaux-et-des-volumes">√âtape 3 : Cr√©ation des r√©seaux et des volumes</h4>
<p>En g√©n√©ral, il y a tr√®s peu de configurations √† ce niveau-l√†. Je vous invite √† aller voir la r√©f√©rence Docker Compose 3 pour avoir plus d&#39;informations sur la configuration des r√©seaux et des volumes. </p>
<p>Il faut surtout <strong>penser √† d√©clarer tous les r√©seaux et les volumes cr√©√©s</strong> :</p>
<pre><code><span class="hljs-symbol">networks:</span>
<span class="hljs-symbol">  main_network:</span>
<span class="hljs-symbol">volumes:</span>
<span class="hljs-symbol">  db_data:</span>
</code></pre><p>Une fois cela fait, le fichier est normalement complet ! On peut donc passer au d√©ploiement !</p>
<h4 id="-tape-finale-d-ploiement-et-maintenance">√âtape finale : D√©ploiement et maintenance</h4>
<p>Apr√®s tout ces efforts pour construire ce fichier, nous pouvons nous placer dans le dossier contenant le docker-compose.yml et utiliser la commande suivante :</p>
<code>$ docker-compose up</code>
<p>Et tadam ! L&#39;application se lance et vous pouvez suivre les logs en direct ! √Ä noter que vous pouvez rajouter l&#39;option <strong>-d</strong> pour lancer l&#39;application en arri√®re-plan. √Ä partir de l√†, voici quelques commandes pratiques :</p>
<pre><code><span class="hljs-variable">$ </span>docker-compose config <span class="hljs-comment"># V√©rifie et affiche la configuration </span>
<span class="hljs-variable">$ </span>docker-compose pause [SERVICE] <span class="hljs-comment"># Met en pause un service</span>
<span class="hljs-variable">$ </span>docker-compose unpause [SERVICE] <span class="hljs-comment"># Sort de pause un service</span>
<span class="hljs-variable">$ </span>docker-compose exec [SERVICE] <span class="hljs-comment"># Lance une commande dans un service</span>
<span class="hljs-variable">$ </span>docker-compose pull <span class="hljs-comment"># R√©cup√®re les derni√®res images des services</span>
<span class="hljs-variable">$ </span>docker-compose down <span class="hljs-comment"># Arr√™te tous les services, d√©truit leurs containers <br/>et leurs r√©seaux (-v pour aussi supprimer les volumes)</span>
</code></pre><p>Sachez aussi que le nom des services a une importance : en effet, il permet de faciliter les communications entre les containers. Les noms de chaque service sont ajout√©s dans le fichier <strong>/etc/hosts</strong> de chaque container avec leurs adresses IP correspondante. Ce qui fait qu&#39;on peut sans probl√®me utiliser la commande :</p>
<pre><code><span class="hljs-symbol">$</span> docker-compose exec <span class="hljs-keyword">prod</span>-web ping db # Lance la commande <span class="hljs-string">"ping db"</span> dans <span class="hljs-keyword">le</span> service <span class="hljs-keyword">prod</span>-web
</code></pre><p>Enfin, Docker Compose permet de faire du semblant de CI (<em>Continuous integration</em> ou int√©gration continue). Cela veut dire que vous pouvez modifier votre fichier docker-compose.yml et appliquer les changements avec une perte de service minime en utilisant <strong>docker-compose up -d</strong>. de la m√™me fa√ßon, on peut utiliser <strong>docker-compose pull</strong> et <strong>docker-compose build</strong> pour mettre √† jour les images puis <strong>docker-compose up -d</strong> pour appliquer les changements.</p>
<p>Voil√† pour cette introduction √† Docker Compose, une technologie bien pratique ! Comme d&#39;habitude, si vous trouvez cette technologie int√©ressante n&#39;h√©sitez pas √† la tester par vous-m√™me ! La r√©f√©rence de Docker Compose est une tr√®s bonne ressource pour faire mumuse avec !</p>
    </div>
	</div>
	<footer>
		Ce site est mise √† disposition selon les termes de la <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Licence Creative Commons Attribution</a>. <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a>
	</footer>
</body>
